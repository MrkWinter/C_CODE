#define _CRT_SECURE_NO_WARNINGS 1
#include<stdio.h>
//复习sizeof
//int main()
//{
//	char b;
//	short c;
//	int a;
//	long d;
//	long long e;
//	float f;
//	double g;
//	int arr[10] = { 0 };
//	printf("%d ", sizeof(char));//1
//	printf("%d ", sizeof(short));//2
//	printf("%d ", sizeof(int));//4
//	printf("%d ", sizeof(long));//4
//	printf("%d ", sizeof(long long));//8
//	printf("%d ", sizeof(float));//4
//	printf("%d ", sizeof(double));//8
//	printf("%d ", sizeof(arr));//40
//	printf("%d ", sizeof(int [10]));//40,数组也有类型，这里为int [10]型的
//	return 0;
//}
//int main()
//{
//	short s = 0;
//	int a = 10;
//	printf("%d", sizeof(s = a + 5));//sizof求的只是所占字节大小，括号里的不参与运算，这里计算的是把a+5赋给s后s的大小,为2
//	printf("%d", s);
//	return 0;
//}
//int main()
//{
//	int a = 0;
//	printf("%d", ~a);
//	//按位取反~
//	//00000000000000000000000000000000 按位取反后  
//	//11111111111111111111111111111111  补码
//	//11111111111111111111111111111110  反码
//	//10000000000000000000000000000001  原码 为-1
//	return 0;
//}
//int main()
//{
//	int a = 11;
//	a = a | (1 << 2);
//	printf("%d ", a);
//	//00000000000000000000000000001011  ---11 把第三位改成1，采用按位或的方式
//	//00000000000000000000000000000100  ---1<<2
//	//00000000000000000000000000001111  ---15
//	a = a & (~(1 << 2));
//	printf("%d ", a);
//	//00000000000000000000000000001111  ---15 再把第三位改为0，采用按位与的方式
//	//11111111111111111111111111111011  ---~(1<<2) 对立面
//	//00000000000000000000000000001011  ---11
//	return 0;
//}
//6.关系操作符
//>  >=  <  <=  !=  ==
//
//7.逻辑操作符
//&&(逻辑与)  ||(逻辑或)  为真为1，为假为0
//int main()
//{
//	int i = 0, a = 0, b = 2, c = 3, d = 4;
//	i = a++ &&  ++b && d++;//逻辑与运算规则，若前面的为假(0),则不执行后面的代码
//	printf("a = %d,b = %d,c = %d,d = %d", a, b, c, d); //1 2 3 4
//	return 0;
//}
//int main()
//{
//	int i = 0, a = 0, b = 2, c = 3, d = 4;
//	i = ++a || ++b || d++;//逻辑或运算规则，若前面的为真(1),则不执行后面的代码
//	printf("a = %d,b = %d,c = %d,d = %d", a, b, c, d); //1 2 3 4
//	return 0;
//}
//8.条件操作符
//exp1 ? exp2 : e xp3
//9.逗号表达式
//exp1，exp2，exp3...expN
//int main()
//{
//	int a = 1;
//	int b = 2;
//	int c = (a > b, a = a - b, a = a + b);//从从左向右依次计算，但最终结果为最后一个表达式的结果
//	printf("%d", c);//1  逗号表达式常用在for，while 等循环中，以最后式子为判断依据
//	return 0;
//}
//10.下标引用，函数调用，结构成员
//1) [] 下标引用操作符 eg: 引用数: 一个数组名 [一个索引值]  []有两个操作数
//2) () 函数调用操作符 eg: 调用: 一个函数名(参数) ()操作数一个是函数名，剩余的是传给函数的参数
//3)  . 结构体变量.成员名   ->  结构体指针->成员名
//下面以结构体为例
//int main()
//{
//	struct student //创建了一个结构体类型 (图纸)
//	{//成员变量
//		char name[20];
//		int age;
//		char id[20];
//	};
//	struct student st1 = { "张三",18,"221498130323" };//定义了一个结构体变量 (房子)
//	struct student* ps = &st1;//结构体指针变量来储存结构体指针st1的地址
//	printf("%s\n", st1.name);//引用结构体变量st1   .操作符来访问成员信息
//	printf("%d\n", (*ps).age);//解引用指针来找到结构体变量st1   .操作符来访问成员信息
//	printf("%s\n", ps->id);//指针直接指向成员
//	return 0;
//}
//操作符作用:表达式求值
//
//隐式类型转换
//整型提升和截取 char和short，低于int大小的进行
//int main()
//{
//	char a = 3;
//	//赋值前进行整型截断
//	//00000000000000000000000000000011
//	//00000011 --整型截断得到3
//	char b = 127;
//	//00000000000000000000000001111111
//	//01111111 --整型截取得到127
//	//a和b如何相加减？(相加减前进行整型提升)（运算前都会进行整型提升）
//	//00000011 --a
//	//00000000000000000000000000000011--a(按照变量的数据类型的符号位来提升的)
//	//01111111 --b
//	//00000000000000000000000001111111--b(提升的数字全为数字的符号位)
//	//00000000000000000000000010000010 --a+b
//	//存入c前进行整型截断
//	//10000010--c
//	char c = a + b;
//	//打印的为整型，再次进行整型提升-(为负数，打印前求下原码)
//	//11111111111111111111111110000010 补码
//	//11111111111111111111111110000001 反码
//	//10000000000000000000000001111110 原码 -- -126
// 	printf("%d", c);
//	return 0;
//}
//整型提升实例
//int main()
//{
//	char a = 1;
//	printf("%u ", sizeof(a));//1 -- %u为无符号输出
//	printf("%u ", sizeof(+a));//4  -- +a进行了算数运算，所以进行了整型提升，变为4个字节
//	printf("%u ", sizeof(!a));//1  -- !a进行了逻辑运算，不进行整型提升
//	return 0;
//}
//算数转换(两两运算时由下至上依次转换)
//long double
//double 
//float 
//unsigned long int 
//long int 
//unsigned int
//int 
//
//操作符的属性
//复杂表达式求值有三个因素的影响
//1)操作符的优先级
//2)操作符的结合性
//3)是否控制求值顺序
//eg:问题表达式
int main()
{
	int i = 1;
	int ret = (++i) + (++i) + (++i);//这里的求值顺序无法清楚的表达，无法通过操作符的属性清楚的求出,所以存在问题
	printf("%d\n", ret);
	printf("%d\n", i);
	return 0;
}