#define _CRT_SECURE_NO_WARNINGS 1
#include<stdio.h>
//如何判断计算机进行的是大端存储还是小端存储
//int main()
//{
//	int  a = 1;//指针类型决定了指针解引用能够访问几个字节
//	char* p = (char*)&a;//char* p 取4个字节中第一个字节的地址存入指针变量p中
//	//printf("%d", *p);//得到结果为1 说明第一个字节存放的为1 数据低位存放在内存低地址处 小端存储
//	if (*p == 1)
//		printf("小端");
//	else
//		printf("大端");
//	return 0;
//}
//优化
//int chack(void)
//{
//	int a = 1;
//	return *((char*)&a); 
//}
//int main()
//{//函数返回1为小端 返回0为大端
//	int ret = chack();
//	if (ret == 1)
//		printf("小端");
//	else
//		printf("大端");
//	return 0;
//}
//练习
//int main()
//{
//	char a = -1;
//	/*10000000000000000000000000000001
//	11111111111111111111111111111110
//	11111111111111111111111111111111补码
//	整型截取 11111111
//	整型提升 111111111111111111111111111111 有符号数整型提升左边补符号位 
//	原码 10000000000000000000000000001  -- -1 负数原返补码不同 需要转换*/
//	signed char b = -1;
//	//同上  -1
//	unsigned char c = -1;
//	/*11111111111111111111111111111111补码
//	整型截取11111111
//	整型提升00000000000000000000000011111111 无符号数整型提升左边补0
//	原码0000000000000000000000111111 -- 255 无符号数与正数原返补码相同*/
//	printf("a=%d b=%d c=%d", a, b, c); /*-1，-1，255*/
//	return 0;
//}
//整形提升与变量的类型有关 与打印的识别形式无关
//计算机存储数字是以补码形式储存的 进行各种计算也是对补码操作的
//在数字输出时要转换为原码进行识别
//数据储存到打印的全过程
//1所有数字都以二进制形式表示为原码（人所认识的）
//2计算机想要储存的数据将原码转换为补码（准备储存）
//3根据所申请的内存空间对补码进行整型截取（可能考虑到大小端存储方式，此时已经存储完成）
//4输出前由该数字的类型决定进行整型提升（准备输出，为补码）
//5根据输出要求对补码进行重定义分析转换成原码输出（输出完成）
//练习
//int main()
//{
//	char a = -128;
//	printf("%d\n", a);
//	//整型提升后为补码1111111111111111111111111000000
//	//补码按有符号数字打印为-128
//	printf("%u\n", a);
//	//整型提升后补码为1111111111111111111111111000000
//	//补码按无符号数字打印为4297964128
//	//%d打印十进制的有符号数字；%u打印十进制的无符号数字
//	return  0;
//}
//有符号char范围为-128~127 无符号char的范围为0~255
//有符号short的范围为-2^15~2^15-1 无符号short的范围为0~2^16
//有符号int的范围为-2^31~2^31-1 无符号int的范围为0~2^32