#define _CRT_SECURE_NO_WARNINGS 1
#include<stdio.h>
//1.算数操作符
//+  -  *  /  %
//int main()
//{
//	float a = 5.0/ 2;//除法想得到小数，式子中必须有小数（否则定义为整数除法）
//	int b = 5 % 2;//取模必须是整数
//	printf("%f %d", a,b);
//	return 0;
//}
//2.移位操作符
//>>  <<
//操作数必须是整数
//右移操作符
//int main()
//{
//	int a = 16;//正数 右移操作符 移的补码 但正数的原码，反码，补码相等
//	int b = a >> 1;//右移操作符，这里按二进制进行算数右移，10000->01000  (有32个比特位，这里简写)//右移有除2的效果
//	printf("%d\n", b);//两种右移方式 1.算数右移--右边丢弃，左边补原符号位
//	printf("%d\n", a);//             2.逻辑右移--右边丢弃，左边补0
//	return 0;
//}
//int main()
//{
//	int a = -1;
//	//整数的二进制表示有原码，反码，补码
//	//储存到内存中的是补码，以-1为例
//	//10000000000000000000000000000001--原码  用二进制表示 第一位符号位为1表示负数 0表示正数
//	//11111111111111111111111111111110--反码  原码符号位不变其他按位取反
// 	//11111111111111111111111111111111--补码  反码加一  移位操作符移的是补码 移位后转换成原码还是-1
//	int b = a >> 1;
//	printf("%d", b);
//	return 0;
//}
//左移操作符
//int main()
//{
//	int a = 5;
//	int b = a << 1;
//	printf("%d\n", b);//左移操作符较简单，00101->01010,二进制整体向左移，右边补0，相当于乘二
//	return 0;
//}
//int main()
//{
//	int a = -1;
//	//负数还是换成原反补码计算
//	//10000000000000000000000000000001 原              10000000000000000000000000000010 原 -->变为-2
//	//11111111111111111111111111111110 反              11111111111111111111111111111101 反
//	//11111111111111111111111111111111 补  左移----->  11111111111111111111111111111110 补
//	int b = a << 1;
//	printf("%d\n", b);
//	return 0;
//}
//总结：左移操作符相当于整数乘法，移动1位相当于乘2，右移操作符相当于整数除法，移动1位相当于除2,左右移动负数位是未定r义的，只能移动正数位
//3.位操作符
//&  |  ^
//操作数必须是整数
//int main()
//{
//	int a = 3;
//	int b = 5;
//	int c = a & b;
//	//00000000000000000000000000000011--a
//	//00000000000000000000000000000101--b
//	//00000000000000000000000000000001--c  按位与&计算相当于合取运算符，补码进行计算
//	printf("%d", c);
//	return 0;
//}
//int main()
//{
//	int a = 3;
//	int b = 5;
//	int c = a | b;
//	//00000000000000000000000000000011--a
//	//00000000000000000000000000000101--b
//	//00000000000000000000000000000111--c  按位或|计算相当于析取运算符，补码进行计算
//	printf("%d", c);
//	return 0;
//}
//int main()
//{
//	int a = 3;
//	int b = 5;
//	int c = a ^ b;
//	//00000000000000000000000000000011--a
//	//00000000000000000000000000000101--b
//	//00000000000000000000000000000110--c  按位异或^计算相同为0相异为1，与等价运算符相反，补码进行计算
//	printf("%d", c);
//	return 0;
//}
//eg;编写一个代码，求一个整数储存在内存中的二进制中1的个数
//int main()
//{
//	int a, i,count=0;
//	scanf("%d", &a);
//	for (i = 0; i < 32; i++)
//	{
//		if ((a >> i) & 1 == 1)//二进制补码&1 若第一位为1则结果为1
//			count++;          //这里使整数补码不断右移，达到检查32位数字中1的个数
//	}
//	printf("%d", count);
//	return 0;
//}
//求正数的二进制，思路：%2后/2不断重复 达到得到每位的效果  类比于10进制%10，/10得到每一位数字
//4.赋值操作符
//=
//1)a = x = y + 1连续赋值 从右至左运算
//2)+=,-=,*=,/=,%=,>>=,<<=,&=,|=,^=,复合赋值符
//
//5.单目操作符
//只有一个操作数
//!  -  +  &(取地址)  sizeof  ~(对一个数的二进制按位取反) 
//--  ++  *(解引用，间接访问操作符)  (类型)(强制类型转换)