#define _CRT_SECURE_NO_WARNINGS 1
#include<stdio.h>
#include<Windows.h>
//练习
//int main()
//{
//	int i = -20;
//	unsigned j = 10;
//	printf("%d", i + j);
//	return 0;
//	//100000000000000000000000 00010100 i的原码
//	//111111111111111111111111 11101011 反码
//	//111111111111111111111111 11101100 补码
//	//000000000000000000000000 00001010 j的补码
//	//111111111111111111111111 11110110 相加后的补码
//	//111111111111111111111111 11110101 相加后的反码
//	//100000000000000000000000 00001010 相加后的原码 -为-10
//}
//int main()
//{
//	unsigned int i = 9;
//	for (i = 9; i >= 0; i--)//无符号数始终大于0 -1的补码为全1在无符号数字中为最大的数
//	{
//		printf("%u\n", i);//陷入死循环
//		Sleep(1000);
//	}
//	return 0;
//}
//int main()
//{
//	char arr[1000];
//	int i;
//	for (i = 0; i < 1000; i++)//遍历-1~-128~0除去0共255个
//	{
//		arr[i] = -1 - i;// \0的assic码值为0
//	}
//	printf("%d", strlen(arr));//225
//	return 0;
//}
//int main()
//{
//	unsigned int i;
//	for (i = 0; i <= 255; i++)
//	{
//		printf("hello world\n");//死循环
//
//	}
//	return 0;
//}
//二、浮点型在内存中的存储
//int main()
//{
//	double i = 1E7;//1的10次方 科学计数法表示
//	printf("%lf", i);
//	return 0;
//}
// int main()
//{
//	int a = 9;
//	float* p = (float*)&a;
//	printf("%d\n", a);//9
//	printf("%f\n", *p);//0.00000
//	*p = 9.0;
//	printf("%d\n", a);//
//	printf("%f\n", *p);//9.0
//	return 0;
//}
//浮点型数据的存储规则
//根据IEEE754国际标准 浮点数统一按以下方式存储
//1.对于一个浮点数 先转换成符号位+二进制科学计数法的形式
//(-1)^S * M * 2^E 
//S表示符号位 S为0表示正数 S为1表示负数
//M表示有效数字
//E表示指数位数
//如9.0 转换成二进制为 1001.0 -> (-1)^0 * 1.001 * 2^3 确定S M E
//2.储存浮点数过程就转换成存储SME的过程
//其中按 S E M 的顺序存储在4字节（float）或8字节（double）中
//3.S占据1bit E占8（11）bit M占23（52）bit
//M因为第一位都为1 故实际存储时省去第一位数字 只存储二进制科学计数法中小数部分
//E因为要存储负数 所以储存时要加上中间值127（8位）或1023（11位） 实际转换输出时减去 以区分正负
//E为全0代表无穷小 E为全1代表无穷大
//举例
//int main()
//{
//	float a = 5.5;
//	//转换成二进制为101.1
//	//(-1)^0 * 1.011 * 2^2 S=0 E=2 M=1.011
//	// 0 100  0000  1 011  00000000000000000000000
//	// 0x40 b0 00 00 小端存储
//	return 0;
//}
//实例分析
// int main()
//{
//	int a = 9;
//	float* p = (float*)&a;
//	//000000000000000000000000 10001 a的原反补码
//	printf("%d\n", a);//9
//	//*p是按照float型来进行转换输出的
//	//000000000000000000000000 10001 a的补码
//	//0 00000000 0000000000000001001――>(-1)^0 * 0.00xx* 2^-127 无穷小
//	printf("%f\n", *p);//0.00000
//	*p = 9.0;	
//	//按浮点数的方式存储在a中
//	//9.0 转换成二进制 1001.0 转换为 (-1)^0 * 1.001 * 2^3
//	//即9的浮点型存储的二进制补码为 0 100000010 00100000000000000000000 转换成原码代表的有符号整数很大
//	printf("%d\n", a);//
//	printf("%f\n", *p);//9.000~ 以浮点数的读取方式得到储存的正确的浮点数
//	return 0;
//}
//总结 浮点型存储方式与整型存储方式不同 读取转换方式也不同 但在x86下都为小端存储方式