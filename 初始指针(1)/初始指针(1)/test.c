#define _CRT_SECURE_NO_WARNINGS 1
#include<stdio.h>
//指针和指针类型
//int main()
//{
//	int a = 383838;
//	int b = 383838;
//	int* pa = &a;//int* 类型的指针变量能存放a的地址
//	*pa = 0;//解引用时认为是int 类型的，访问4个字节
//	char* pb = &b;//char* 类型的指针变量也能存放b的地址
//	*pb = 0;//解引用时认为是char 类型的，访问1个字节
//	printf("%d ", a);//0
//	printf("%d ", b);//383744
//	return 0;
//	//总结：指针类型决定了指针进行解引用操作的时候，能访问空间的大小
//	//char* p 能访问1个字节
//	//char* p 能访问4个字节
//	//double* p 能访问8个字节
//	//使用指针时应选择合适的类型来使用
//}
//int main()
//{
//	int a = 9999;
//	int* pa = &a;
//	char* paa = &a;
//	printf("%p\n", pa);//int* 类型的指针
//	printf("%p\n", pa+1);//指针变量存放的地址向后跳了4个字节 +2跳过8个字节
//	printf("%p\n", paa);//char* 类型的指针
//	printf("%p\n", paa+1);//指针变量存放的地址向后跳了1个字节 +2跳过2个字节
//	return 0;
//	//总结：指针类型决定了走一步多远（指针的步长）
//	//指针的类型决定了指针变量实际代表地址的连续长度（连续的多块内存）
//}
//int main()
//{
//	int i;
//	int arr[10] = { 0 };
//	int* pa = arr;//数组的首元素地址存到int* 类型的指针变量里
//	for (i = 0; i < 10; i++)
//	{
//		*(pa+i) = 1;//依次访问每个元素的地址，将每个元素改为1
//	}
//	for (i = 0; i < 10; i++)
//	{
//		printf("%d ",arr[i]);//打印数组
//	}
//	return 0;
//}
//int main()
//{
//	int i;
//	int arr[10] = { 0 };
//	char* pb = arr;//数组的首元素地址存到char* 类型的指针变量里
//	for (i = 0; i < 40; i++)
//	{
//		*(pb + i) = 1;//将整型4个字节代表的数字分成4份，每个字节改为1
//	}
//	for (i = 0; i < 10; i++)
//	{
//		printf("%d ", arr[i]);//打印数组  每个元素为16843009
//		                      //原因：改后的每个元素的二进制序列为 00000001000000010000000100000001（int类型）
//		                      //变换为十进制为 16843009 也就是把每4个连续的字节都改为了00000001（十进制数字1）
//	} 
//	return 0;
//}
//野指针
//1)指针未初始化
//int main()
//{
//	int a;//未初始化的局部变量为随机值
//	int* p;//未初始化的指针变量也为随机值
//	//*p = 20;//error! 不能把20存在一块随机的内存中  未指定地址的赋值
//	return 0;
//}
//2)指针访问越界
//int main()
//{
//	int i;
//	int arr[10] = { 0 };
//	int* pa = arr;
//	for (i = 0; i <= 10; i++)
//	{
//		//*(pa + i)=1;//error!数组只分配了10个块整型内存，第11块为指针访问越界 （指定地址，但地址所代表的内存程序没有控制权）
//	}
//	return 0;
//}
//3)指针指向空间释放
int* test()
{
	int a = 10;//在函数内部的局部变量，出函数内存即释放
	return &a;
}
int main()
{
	int* p = test();//地址返回后，函数内部的那块内存释放了，已经失去了程序对内存的控制权
	*p = 123;//那块内存里的变量a已经不属于程序的控制了（指定地址，地址所代表的内存程序没有控制权）
	return 0;
}